:imagesdir: ./images

[[models]]
# Modellparametrisierung

In diesem Abschnitt werden die verschiedenen Modellparametrisierungsblöcke beschrieben. Modelle werden verwendet, um gleichartige Funktionalität für mehrere Objekte (meist Zonen) zu definieren. Die in den Modellblöcken abgelegten Parameter gelten dann für alle (via Objektlisten) ausgewählten Objekte. Allerdings können objektspezifische Eigenschaften (bspw. Nutzfläche bei Zonen) in die Modell einfließen.


.Modelldefinitionslisten innerhalb des XML-Elements `Models`
====
[source,xml]
----
<Models>
	<NaturalVentilationModels>
	    ...
	</NaturalVentilationModels>
	
	... weitere Modell-Definitionsblöcke ...

    <IdealPipeRegisterModels>
        ...
    </IdealPipeRegisterModels>
</Models>
----
====

## Modellüberblick

[width="100%",options="header", cols="15%,85%"]
|====================
| XML-Tag | Modell/Kurzbeschreibung
| `NaturalVentilationModels` | Natürliche Lüftung/Infiltration -> <<model_natural_ventilation>>
| `ShadingControlModels` | Kontrollmodell für dynamische Verschattung -> <<model_shading_control>>
| `InternalLoadsModels` | Interne Lasten (Geräte, Personen, Beleuchtung) -> <<model_internal_loads>>
| `Thermostats` | Kontrollmodell für Temperaturregelung -> <<model_thermostats>>
| (*) `HVACControlModels` | Kontrollmodell für erweiterte Klimaanlagenregelung -> <<model_HVAC_control>>
| `IdealHeatingCoolingModels` | Ideale Beheizung/Kühlung von Zonen -> <<model_ideal_heating_cooling>>
| `IdealSurfaceHeatingCoolingModels` | Ideale Flächenheizsysteme/Fußbodenheizungen/Betonkernaktivierung -> <<model_ideal_surface_heating_cooling>>
| `IdealPipeRegisterModels` | Idealisierte Rohrregister-Flächenheizungen -> <<model_ideal_pipe_register>>
| `HeatLoadSummationModels` | Summationsmodelle für Heizleistungen -> <<model_heat_load_summation>>
| `NetworkInterfaceAdapterModels` | Adaptermodelle für externe Netzwerkschnittstellen -> <<model_network_interface_adapter>>
|====================

__(*) noch nicht implementiert__

[[model_natural_ventilation]]
## Natürliches Lüftungsmodell

Das Modell für natürliche Lüftung definiert den Luftaustausch mit der Außenluft und beinhaltet Nutzerlüftung wie ungewollte Lüftung durch Leckagen (Fugenlüftung/Infiltration). Die natürliche Lüftung wird für bestimmte Zonen aktiviert, indem ein Modellparametersatz `NaturalVentilationModel` definiert wird. Über die Objektliste werden die Zonen ausgewählt.

.Drei veschiedene Modellvarianten und deren Parameter beim Modell für natürliche Lüftung/Infiltration
====
[source,xml]
----
<!-- Lüftungsmodell mit durchgängig konstanter Infiltration/Grundluftwechsel -->
<NaturalVentilationModel id="501" displayName="Zone vent" modelType="Constant">
	<ZoneObjectList>Office zones</ZoneObjectList>
	<IBK:Parameter name="VentilationRate" unit="1/h">0.5</IBK:Parameter>
</NaturalVentilationModel>

<!-- Lüftungsmodell mit zeitabhängig geregelter Luftwechselrate -->
<NaturalVentilationModel id="502" displayName="Zone vent" modelType="Scheduled">
	<ZoneObjectList>Other zones</ZoneObjectList>
</NaturalVentilationModel>

<!-- Lüftungsmodell mit zeitabhängigem Grundluftwechsel und bedarfsweise erhöhter Luftwechselrate -->
<NaturalVentilationModel id="503" displayName="Zone vent" modelType="ScheduledWithBaseACR">
	<ZoneObjectList>Special zones</ZoneObjectList>
	<!-- Komfortbereich wird durch min und max Temperaturen angegeben :
	     Erhöhte Lüftungsrate verwenden, wenn Raumtemperatur 24°C überschreitet und es draußen kälter ist. -->
	<IBK:Parameter name="MaxAirTemperature" unit="C">24</IBK:Parameter>
	<!-- Erhöhung der Lüftungsrate verwenden, wenn Raumtemperatur 18°C unterschreitet und es draußen wärmer ist. -->
	<IBK:Parameter name="MinAirTemperature" unit="C">18</IBK:Parameter>
	<!-- Über 10 m/s wird die erhöhte Lüftung ausgeschaltet. -->
	<IBK:Parameter name="MaxWindSpeed" unit="m/s">10</IBK:Parameter>
</NaturalVentilationModel>
----
====


[IMPORTANT]
====
Es darf nur ein Lüftungsmodellblock pro Zone gelten. Es dürfen also nicht zwei Lüftungsmodellblöcke mit Objektlisten definiert werden, die beide die gleiche(n) Zone(n) enthalten.
====

Das `NaturalVentilationModel` unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des natürlichen Lüftungsmodells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_

| `modelType` 
a| Setzt den Typ des Lüftungsmodells 

* `Constant` - Konstante Luftwechselrate
* `Scheduled` - Luftwechselrate ändert sich nach einem definierten Zeitplan. Dieses Modell sollte verwendet werden, wenn ein spezielles Lüftungsmodell über die FMU-Schnittstelle dazugeschaltet wird.

* `ScheduledWithBaseACR` - Es werden ein Grundluftwechsel und eine _Erhöhung_ des Luftwechsels jeweils als zeitabhängige Zeitpläne gegeben. Die Aktivierung des zusätzlichen Luftwechsels hängt an zusätzlichen Kriterien.

* (*)`Realistic`- Lüftungsrate ergibt sich aus physikalischen Bedingungen (Wind, Temperaturdifferenzen, Fensteröffnungszustand, ...)

| key | _erforderlich_
|====================

_(*) wird noch nicht verwendet/noch nicht implementiert_

Gleitkommazahlen-Parameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`):

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `VentilationRate` | 1/h | Konstante Luftwechselrate | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich für Modelltyp_ `Constant`
| `MaxAirTemperature` | C | obere Raumluft-Grenztemperatur | {nbsp}>={nbsp}-100.0{nbsp} | _erforderlich für Modelltyp_ `ScheduledWithBaseACR`
| `MinAirTemperature` | C | untere Raumluft-Grenztemperatur | {nbsp}>={nbsp}-100.0{nbsp} | _erforderlich für Modelltyp_ `ScheduledWithBaseACR`
| `MaxWindSpeed` | m/s | maximale Windgeschwindigkeit für erhöhte Lüftung | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich für Modelltyp_ `ScheduledWithBaseACR`
|====================

Beim Modelltyp `Constant` wird durchweg eine konstante Luftwechselrate (Parameter `VentilationRate`) verwendet.

Beim Modelltyp `Scheduled` wird die Luftwechselrate aus einem Zeitplan (Parameter `VentilationRateSchedule`, siehe <<schedules>>) entnommen. Weitere Parameter sind nicht notwendig.

Nachfolgend finden Sie ein Beispiel für einen Zeitplan, der den Parameter `VentilationRateSchedule` für ein solches Modell der geplanten natürlichen Lüftung bereitstellt:

.Zeitplan, der den Parameter _VentilationRateSchedule_ bereitstellt
====
[source,xml]
----
<ScheduleGroup objectList="All zones">
	<!-- jeden Tag zwischen 6-10 -->
	<Schedule type="AllDays">
		<DailyCycles>
			<DailyCycle interpolation="Constant">
				<TimePoints>0 6 10</TimePoints>
				<Values>VentilationRateSchedule [1/h]:0 0.4 0</Values>
			</DailyCycle>
		</DailyCycles>
	</Schedule>
	<!-- Dienstag keine Lüftung -->
	<Schedule type="Tuesday">
		<DailyCycles>
			<DailyCycle interpolation="Constant">
				<TimePoints>0</TimePoints>
				<Values>VentilationRateSchedule [1/h]:0</Values>
			</DailyCycle>
		</DailyCycles>
	</Schedule>
	<!-- Wochenende nur am Nachmittag -->
	<Schedule type="WeekEnd">
		<DailyCycles>
			<DailyCycle interpolation="Constant">
				<TimePoints>0 14 16</TimePoints>
				<Values>VentilationRateSchedule [1/h]:0 0.1 0</Values>
			</DailyCycle>
		</DailyCycles>
	</Schedule>
</ScheduleGroup>
----
====


Beim Modelltyp `ScheduledWithBaseACR` wird ein Grundluftwechsel (Schedule `VentilationRateSchedule`) analog zum Modelltyp `Scheduled` verwendet. Unter bestimmten Bedingungen wird dieser Grundluftwechsel durch ein zusätzlichen Luftwechsel entsprechend eines gegebenen Zeitplans in  `VentilationRateIncreaseSchedule` *erhöht*.

Die Luftwechselrate wird berechnet:

```
n = n_Grundluftwechsel                          // wenn Bedingungen nicht erfüllt
n = n_Grundluftwechsel + n_erhöhterLuftwechsel  // wenn Bedingungen erfüllt
```

[IMPORTANT]
====
Bei Definition der `VentilationRateIncreaseSchedule` für das `ScheduledWithBaseACR` beachten, dass dies die _zusätzliche_ Lüftungsrate zum Grundluftwechsel ist.
====

.Zeitplan für Modelltyp `ScheduledWithBaseACR`; Grundluftwechsel = 0.5 1/h, Luftwechsel bei Erhöhung = 2 1/h = (0.5 + 1.5) 1/h
====
[source,xml]
----
<ScheduleGroup objectList="All zones">
	<Schedule type="AllDays">
		<DailyCycles>
			<DailyCycle interpolation="Constant">
				<TimePoints>0</TimePoints>
				<!-- Basis Luftwechselrate -->
				<Values>
				    VentilationRateSchedule [1/h]:0.5;
					VentilationRateIncreaseSchedule [1/h]:1.5
				</Values>
			</DailyCycle>
		</DailyCycles>
	</Schedule>
</ScheduleGroup>
----
====
### Regelbedingungen

Die Komfortlüftung (Modelltyp `ScheduledWithBaseACR`) folgt einer einfachen Logik:

- der Grundluftwechsel reicht aus, solange die Raumlufttemperatur zwischen den gegebenen Parametern `MinAirTemperature` und `MaxAirTemperature` liegt
- sobald der Komfortbereich verlassen wird, wird die zusätzliche Luftwechselrate angewendet, _ aber nur, falls eine Lüftung hilfreich ist_. D.h. durch die erhöhte Lüftung muss die Raumlufttemperatur in Richtung Komfortzone bewegt werden. 

#### Beispiel Kühlung im Sommerfall

- `MaxAirTemperature = 26 C`
- Falls die Raumlufttemperatur > 26 C wird, kann die erhöhte Lüftung benutzt werden, aber nur solange die Außenlufttemperatur kleiner als die aktuelle Raumlufttemperatur ist.

### Ausgabegrößen

Das Lüftungsmodell generiert folgende vektorwertige Ergebnisgrößen:

- `VentilationHeatFlux` in [W]
- `VentilationRate` in [1/h] und 

[NOTE]
====
Da es mehrere Lüftungsmodellinstanzen geben kann, sucht das jeweilige Zonenmodell zunächst, welche Modellinstanz eine Ergebnisgröße liefert und erstellt dann die Verknüpfung zur Eingangsvariable.
====


[[model_shading_control]]
## Steuerungsmodell für Verschattung

Ein Verschattungregelungsmodell ist eine spezielle Art von Regelungsmodell, das einen Signalwert zwischen 0 (keine Verschattung) und 1 (volle Verschattung) zurückgibt. Das tatsächliche Ausmaß der Verschattung bzw. die Reduzierung der solaren Gewinne wird durch den Verschattungs-Parameterblock (`Shading`, siehe <<window_shading>>) bestimmt. Somit kann das gleiche Regelmodell für verschiedene Verschattungseinrichtungen verwendet werden. Da es bei Verschattungseinrichtungen keinen expliziten Zonenbezug gibt, werden Verschattungskontrollmodelle über ihre eindeutige ID referenziert.

.Parameterdefinition für Verschattungsregelungsmodell
====
[source,xml]
----
<Models>
    <ShadingControlModels>
    	<!-- ShadingControlModel liefert einen Wert zwischen 0 und 1 
    		0 = keine Reduktion (Verschattung offen)
    		1 = volle Reduktion (Verschattung geschlossen)
    	-->
    	<ShadingControlModel id="2000" displayName="Global horizontal sensor controller" sensorId="50000">
    		<IBK:Parameter name="MaxIntensity" unit="W/m2">300</IBK:Parameter>
    		<IBK:Parameter name="MinIntensity" unit="W/m2">150</IBK:Parameter>
    	</ShadingControlModel> 
    </ShadingControlModels>
</Models>
----
====

Das `ShadingControlModel` unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_
|====================

Das Verschattungskontrollmodell verlangt zwei Parameter `MaxIntensity` und `MinIntensity` und implementiert eine digitale Regelung mit Hysterese. Zunächst muss die Globalstrahlungsintensität auf den Sensor den oberen Grenzwert (`MaxIntensity`) überschreiten, wonach die Verschattung geschlossen wird (Kontrollmodell liefert 1). Danach muss die Strahlungsintensität zunächst unter die untere Grenze sinken (`MinIntensity`), bevor die Verschattung wieder geöffnet wird (Kontrollmodell liefert 0).

Für die Auswertung wird eine Horizontalstrahlung benötigt. Dafür muss eine Oberfläche ausgewählt werden und als `sensorId` angegeben werden. 

Möglich sind hier 3 Optionen:

- allgemeiner Sensor auf einer Fläche (siehe <<location_sensors>>)
- ID eines Fensters (eigentlich ID des _embedded object_, welches das Fenster enthält); hier wird die Globalstrahlung durch das Fenster als Eingangsgröße verwendet, einschließlich eventueller externer Verschattung bzw. Eigenverschattung 
- ID einer opaquen Fläche; hier wird die Globalstrahlung auf eine opaque Fläche als Eingangsgröße verwendet, einschließlich eventueller externer Verschattung bzw. Eigenverschattung 

Damit diese IDs eindeutig auflösbar sind, müssen Sensoren, Fenster und Konstruktionen global eindeutige IDs tragen (siehe auch <<uniqueness_requirements>>).

### Ausgabegrößen

Das Verschattungssteuerungsmodell liefert als Ergebnisgrößen:

- `ShadingControlValue` - Steuerungssignal für Verschattung: 0 - komplett offen, 1 - komplett geschlossen, Zwischenwerte sind möglich
- `SolarIntensityOnShadingSensor` - Solarstrahlungsintensität in [W/m2] auf ausgewählten Sensor, der für die Regelung verwendet wird



[[model_internal_loads]]
## Modell für interne Lasten

Das Modell für interne Lasten wird verwendet, um die Wärmelasten von Geräten, Personen und Beleuchtung für Zonen zu definieren. Interne Lasten werden genauso definiert wie natürliche Lüftungsmodelle. Der Objektlisten-tag `ZoneObjectList` identifiziert die Zonen, in denen interne Lasten berücksichtigt werden sollen. Wie auch beim Modell für natürliche Lüften dürfen Zonen immer nur einmal referenziert werden (es  dürfen nicht zwei interne Lastmodelle existieren, die sich auf dieselben Zonen beziehen).

.Definitionsblock für interne Lasten
====
[source,xml]
----
<InternalLoadsModel id="200" modelType="Scheduled">
	<ZoneObjectList>Office zones</ZoneObjectList>
	<IBK:Parameter name="RadiantFraction" unit="---">0.5</IBK:Parameter>
</InternalLoadsModel>
----
====


Das `InternalLoadsModel` unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_

| `modelType` 
a| Gibt an, wie die internen Lasten angesetzt werden sollen

* `Constant` - Konstante Geräte-, Personen- und Beleuchtungsenergielasten
* `Scheduled` - Lasten werden über Zeitplanparameter bereitgestellt.

| key | _erforderlich_
|====================


Fließkommaparameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`):

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `EquipmentHeatLoadPerArea` | W/m2 | Komplette Gerätebelastung pro Zonennutzfläche | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich für Konstantes Modell_
| `PersonHeatLoadPerArea` | W/m2 | Komplette Personenwärmelast pro Zonennutzfläche | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich für Konstantes Modell_
| `LightingHeatLoadPerArea` | W/m2 | Komplette Wärmelast aus Beleuchtung pro Zonennutzfläche | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich für Konstantes Modell_
| `EquipmentRadiationFraction` | --- | Prozentualer Anteil der Wärme der Geräte, der durch Strahlung emittiert wird | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_
| `PersonRadiationFraction` | --- | Prozentualer Anteil der Wärme der Personen, der durch Strahlung emittiert wird | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_
| `LightingRadiationFraction` | --- | Prozentualer Anteil der Wärme der Beleuchtung, der durch Strahlung emittiert wird | {nbsp}>={nbsp}0,0{nbsp} | _erforderlich_
|====================

[NOTE]
====
Die _Zonennutzfläche_ ist nicht zwingend die _Grundfläche_ einer Zone sondern wird aus dem Parameter _Area_ der Zonendefinition gewählt. Dadurch ist es möglich, z.B. im Dachgeschoss mit Schrägen, die tatsächlich nutzbare Fläche zu definieren und zu verwenden. Deshalb wird der _Area_ Parameter in allen Zonen benötigt, für die ein `InternalLoadsModel` angewendet werden soll.
====

Die Parameter `xxxRadiationFraction` geben an, welcher Prozentsatz der berechneten internen Lasten als Strahlungsfluss flächengewichtet auf opake Oberflächen, die die Zone umschließen, aufgebracht werden soll. 

Der Modelltyp `Constant` übernimmt die internen Lasten aus den Parametern (siehe oben).

Wenn der Modelltyp `Scheduled` verwendet wird, werden die tatsächlichen Lasten aus dem Zeitplan entnommen.

Die folgenden Zeitplanparameter sind erforderlich:

- `EquipmentHeatLoadPerAreaSchedule [W/m2]`
- `PersonHeatLoadPerAreaSchedule [W/m2]`
- `LightingHeatLoadPerAreaSchedule [W/m2]`

### Ausgaben 

Das Modell stellt folgende Ausgangsgrößen zur Verfügung: 

- `ConvectiveEquipmentHeatLoad [W]`
- `ConvectivePersonHeatLoad [W]`
- `ConvectiveLightingHeatLoad [W]`
- `RadiantEquipmentHeatLoad [W]`
- `RadiantPersonHeatLoad [W]`
- `RadiantLightingHeatLoad [W]`

Dies sind vektoriell dargestellte Größen, die in Ausgangsdefinitionen referenziert werden müssen, z. B. mit: `ConvectiveEquipmentHeatLoad[id=3]` für die konvektive Gerätelast in Zone #3.




[[model_thermostats]]
## Modell für Thermostate

Das Thermostatmodell beschreibt, auf welche Raumsollwerte konditioniert werden soll. Angegeben werden können Heiz- und/oder Kühlsolltemperaturen für die Raumluft oder operative Raumluft.
Der Objektlisten-tag `ZoneObjectList` identifiziert die Zonen, in denen Thermostate berücksichtigt werden sollen. Wie auch beim Lüftungsmodell  darf nur ein Modell pro Zone existieren.

.Definitionsblock für Thermostate
====
[source,xml]
----
<!-- A thermostat with constant heating and cooling set points. Uses air temperature as sensor value. -->
<Thermostat id="1001" displayName="Constant air temperature thermostat" modelType="Constant">
	<ZoneObjectList>All zones</ZoneObjectList>
	<!-- Heating starts below 22 C -->
	<IBK:Parameter name="HeatingSetpoint" unit="C">22</IBK:Parameter>
	<!-- Cooling starts above 26 C -->
	<IBK:Parameter name="CoolingSetpoint" unit="C">26</IBK:Parameter>
	<!-- P-controller is accurate to 0.2 K -->
	<IBK:Parameter name="TemperatureTolerance" unit="K">0.2</IBK:Parameter>
	<!-- Control temperature is "Air temperature", this is the default and could be omitted -->
	<TemperatureType>AirTemperature</TemperatureType>
	<!-- Controller type Analog is the default, so we could omit this-->
	<ControllerType>Analog</ControllerType>
</Thermostat>
----
====


Das `Thermostat`-Element unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_

| `modelType` 
a| Gibt an, wie die Thermostat-Parameter angesetzt werden sollen

* `Constant` - Konstante Sollwerte
* `Scheduled` - Sollwerte werden über Zeitplanparameter bereitgestellt.

| key | _erforderlich_
|====================


Fließkommaparameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`):

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `HeatingSetpoint` | C | konstanter Heizsollwert | < `CoolingSetpoint` | _erforderlich für Modelltyp_ `Constant`
| `CoolingSetpoint` | C | konstanter Kühlsollwert | > `HeatingSetpoint` | _erforderlich für Modelltyp_ `Constant`
| `TemperatureTolerance` | K | Toleranz für analoges Thermostat und Normalisierungswert | > 0 | _erforderlich für Controllertyp_ `Analog`
| `TemperatureBand` | K | Totband für digitales Thermostat | > 0 | _erforderlich für Controllertyp_ `Digital`
|====================

Der Modelltyp `Constant` übernimmt die Sollwerte aus den Parametern (siehe oben).

Wenn der Modelltyp `Scheduled` verwendet wird, werden die tatsächlichen Sollwerte aus dem Zeitplan entnommen. Dafür sind folgende Zeitplanparameter erforderlich:

- `HeatingSetpointSchedule [C]`
- `CoolingSetpointSchedule [C]`

[NOTE]
====
Ein Thermostat hält nur die Sollwerte für die Zone. Eine Konditionierung der Zone erfolgt erst, wenn zusätzlich eine Heizungs- und/oder Kühlmodell für die Zone integriert ist. Bei den Zeitplänen ist immer darauf zu achten, dass der Heizsollwert < Kühlsollwert ist.
====

### TemperatureType

Das XML-Element `TemperatureType` enthält eine Zeichenkette zur Auswahl eines bestimmten Typs (`AirTemperature` wird standardmäßig verwendet, wenn das Element fehlt).

.Verfügbare Temperatursensoren
[options="header", cols="20%, 80%", width="100%"]
|====================
|Name|Beschreibung
|`AirTemperature`| Als Referenztemperatur wird die Raumlufttempatur verwendet.
|`OperativeTemperature`| Als Referenztemperatur wird die operative Raumlufttempatur verwendet. Diese setzt sich aus der mittleren Oberflächentemperatur aller Innenoberflächen und aus der Raumlufttemperatur zusammen. Die Anteile betragen jeweils 50%.
|====================


### ControllerType

Das XML-Element `ControllerType` enthält eine Zeichenkette zur Auswahl des gewünschten Signaltyps (`Analog` wird standardmäßig verwendet, wenn das Element fehlt).

.Verfügbare Schalt-/Regelsignale
[options="header", cols="20%, 80%", width="100%"]
|====================
|Name|Beschreibung
|`Analog`| Die Abweichung zwischen Solltemperatur und Sensortemperatur wird durch die `TemperatureTolerance` geteilt zurückgeliefert. Je weiter von 0 verschieden das Sensorsignal ist, umso größer ist die Abweichung. Ein Wert < 1 besagt, dass die Abweichung noch in der Toleranz liegt.
|`Digital`| Ein digitaler Controller mit Hysterese wird verwendet.
|====================

Beim Typ `Analog` muss der Parameter `TemperatureTolerance` angegeben werden, welche die nominal erlaubte Regelabweichung definiert. Wird z.B. die Heizsolltemperatur um genau diese Toleranz unterschritten, so liefert der Regler eine 1 zurück (bei größeren Abweichungen entsprechend höhere Werte).

Beim Typ `Digital` muss der Parameter `TemperatureBand` angegeben werden. Der Regler regelt dann im Bereich;

----
obere Grenze = Sollwert + TemperatureBand
untere Grenze = Sollwert - TemperatureBand
----

### Ausgaben

Das Modell liefert vektorwertige Modellergebnisgrößen, wobei der Vektorindex die jeweilige Zonen-ID ist.

- `HeatingControlValue [---]` - Steuersignal für die Heizungsanlage: 0 - aus, 1 - maximal an, Wertebereich unbegrenzt
- `CoolingControlValue [---]` - Steuersignal für die Klimaanlage: 0 - aus, 1 - maximal an, Wertebereich unbegrenzt
- `ThermostatHeatingSetpoint [C]` - Setpoint, der für die Heizung verwendet wurde
- `ThermostatCoolingSetpoint [C]` - Setpoint, der für die Kühlung verwendet wurde

[NOTE]
====
Es kann mehrere Thermostat-Modell-Instanzen im Gebäude geben. Da die Ergebnisgrößen von der jeweiligen Modellinstanz selbst zur Verfügung gestellt werden, muss beim Zugriff auf die jeweiligen zonenspezifischen Regelgrößen (`XXXControlValue`) das richtige Modell addressiert werden. In der Praxis kann das so geschehen, dass ein nachfolgendes Modell einfach optionale Eingangsreferenzen für Regelgrößen einer Zonen an _alle_ Thermostatmodelle schickt. Es darf dann nur exakt ein Modell eine Ergebnisgröße liefern, die dann verwendet wird.
====



[[model_HVAC_control]]
## Anlagensystem-Modell

!NOCH NICHT IMPLEMENTIERT!

Ein Anlagensystem-Modell wandelt Regelinformationen aus einem Thermostat und ggfs. anderen Prozessbedingungen in Regelgrößen für spezifische Heizsysteme um. So können auch Priorisierungen implementiert werden.

Ein Anlagensystem-Modell ist optional - ohne ein solches System kann ein Heizungssystem auch direkt die Kontrollgrößen eines Thermostats abgreifen.

.Anlagensystemmodell für die Umsetzung einer idealen Heizung
====
[source,xml]
----
<HVACControlSystem id="200" modelType="Heating">
    <HeatingSystems>Ideal</HeatingSystem>
    <Priority>Parallel</Priority>
</HVACControlSystem>
----

TODO : 

====



[[model_ideal_heating_cooling]]
## Modell für ideale thermische Konditionierung

Das Modell beschreibt eine ideale thermisches Raumluftkonditionierung. Der Objektlisten-tag `ZoneObjectList` identifiziert die Zonen, in denen das Modell berücksichtigt werden sollen. Es darf  nur ein Modell pro Zone existieren (d.h. bei mehreren `IdealHeatingCoolingModel` Definitionen dürfen die Objektlisten nicht gleiche Zonen enthalten).

.Definitionsblock für ideale thermische Konditionierung
====
[source,xml]
----
<IdealHeatingCoolingModel id="200" displayName="Air heating">
	<ZoneObjectList>Office zones</ZoneObjectList>
	<IBK:Parameter name="MaxHeatingPowerPerArea" unit="W/m2">50</IBK:Parameter>
	<IBK:Parameter name="MaxCoolingPowerPerArea" unit="W/m2">20</IBK:Parameter>
</IdealHeatingCoolingModel>
----
====

Das `IdealHeatingCoolingModel` unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_
|====================


Fließkommaparameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`):

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `MaxHeatingPowerPerArea` | W/m2 | maximale flächenbezogene Heizleistung in Bezug auf Raumnutzfläche | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `MaxCoolingPowerPerArea` | W/m2 | maximale flächenbezogene Kühlleistung in Bezug auf Raumnutzfläche | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `Kp` | --- | Faktor für den propotionalen Teil des Kontrollers | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `Ki` | --- | Faktor für den integralen Teil des Kontrollers | {nbsp}>={nbsp}0.0{nbsp} | _optional_ 
|====================

[IMPORTANT]
====
Damit das Modell auf die jeweilige Zone angewendet wird, ist zwingend das <<model_thermostats, Thermostat>> nötig, welches für die gleichen Zone parametriert sein muss. Dieses liefert dann eine Ergebnisgröße `Model(<thermostat_id>).HeatingControlValue[<zone id>]`. 

Ein zwischengeschaltetes `HVACControlSystem` kann optional verwendet werden (auch als FMU), welches ein konkretisiertes Regelsignal `Model(<HVACControlSystem_id>).IdealHeatingControlValue[<zone id>]` liefert. Das `IdealHeatingCoolingModel`-Modell sucht _zuerst_ nach einer gülten Variable vom HVACControlSystem-Modell, und dann nach dem Thermostat. 

!DIESES IST NOCH NICHT IMPLEMENTIERT!
====

### Heiz- und Kühlleistung

Das Regelsignal `HeatingControlValue` bzw. `IdealHeatingControlValue` wird als Wert zwischen 0..1 interpretiert. Werte außerhalb dieser Grenzen werden abgeschnitten. Bei 1 läuft die Heizung mit maximaler Heizlast. Bei 0 ist die Heizung aus. Dazwischen wird linear interpoliert.

Die Kühlung ist analog definiert. Bei einem Kontrollwert von 1 läuft die Kühlung mit maximaler Kraft, bei 0 ist sie aus. 

Das so bestimmte Regeleingangssignal geht in einen P-Regler ein. Falls der `Ki` Parameter gegeben ist, wird stattdessen ein PI-Regler verwendet. Die so berechnet Heiz- und Kühlleistung wird durch den `MaxHeatingPowerPerArea`-Parameter bzw. `MaxCoolingPowerPerArea`-Parameter begrenzt.

### Ausgaben

Ergebnisgrößen des Modells sind:

- `IdealHeatingLoad [W]`
- `IdealCoolingLoad [W]`

Analog zu Lüftungswärmeverlusten werden diese zonenspezifischen Ausgangsgrößen als vektorwertige Ergebnisgrößen bereitgestellt.
Z. B. ist `Model<IdealHeatingCoolingModel_id>).IdealHeatingLoad[id=3]` die Heizlast in Zone #3.

[CAUTION]
====
Die Kühllast ist positiv definiert, geht jedoch als negative Flussgröße in die Raumenergiebilanz ein. In Ausgaben wird die Kühllast `IdealCoolingLoad` jedoch immer als positive Größe ausgegeben.
====



[[model_ideal_surface_heating_cooling]]
## Modell für ideale Flächenheizungen

Das Modell beschreibt ein ideales thermisches Konditionierungsmodell für eine Flächenheizung. Dies kann eine Fußbodenheizung sein, eine Kapillarrohrmatte, ein elektrisches Heizregister oder eine Betonkernaktivierung. Der Wärmeübertragungsmechanismus ist nicht abgebildet, es wird lediglich Wärme der beheizten/gekühlten Konstruktionsschicht zugefügt oder entfernt.

.Definitionsblock für ideale Flächenheizungen
====
[source,xml]
----
<IdealSurfaceHeatingCoolingModel id="701" displayName="Floor heating">
	<!-- Use thermostat in zone 1 for control -->
	<ThermostatZoneId>1</ThermostatZoneId>
	<ConstructionObjectList>Floor</ConstructionObjectList>
	<!-- Maximum heating power per construction/surface area, here: 10 m2 * 150 W/m2 = 1500 W -->
	<IBK:Parameter name="MaxHeatingPowerPerArea" unit="W/m2">150</IBK:Parameter>
</IdealSurfaceHeatingCoolingModel>
----
====

Das `IdealSurfaceHeatingCoolingModel` unterstützt folgende XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_
|====================


Fließkommaparameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`):

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `MaxHeatingPowerPerArea` | W/m2 | maximale flächenbezogene Heizleistung in Bezug auf die Fläche der beheizten Konstruktion | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `MaxCoolingPowerPerArea` | W/m2 | maximale flächenbezogene Kühlleistung in Bezug auf die Fläche der beheizten Konstruktion| {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
|====================

Ein `IdealSurfaceHeatingCoolingModel` kann die Heiz- und Kühlleistung in mehreren Konstruktionen berechnen. Dafür identifiziert der Objektlisten-tag `ConstructionObjectList` die Konstruktion, welche durch das Modell beheizt werden. Jede beheizte Konstruktion darf nur von einem Modell angesprochen werden.

[IMPORTANT]
====
Die in der Objektliste referenzierten Konstruktionen müssen einen Konstruktionstyp haben, in dem eine aktive Schicht definiert ist (siehe <<construction_active_layer>>).
====

Die Flächenheizung/-kühlung wird durch ein Thermostat gesteuert. Die Zone, in der sich das Thermostat befindet, wird im Element `ThermostatZoneId` angegeben.

### Heiz- und Kühlleistung

Das Regelsignal `HeatingControlValue` wird als Wert zwischen 0..1 intepretiert. Werte außerhalb dieser Grenzen werden abgeschnitten. Bei 1 läuft die Heizung mit maximaler Heizlast, entsprechend des `MaxHeatingPowerPerArea`-Parameters. Bei 0 ist die Heizung aus. Dazwischen wird linear interpoliert.

Die Kühlung ist genauso definiert. Bei einem Kontrollwert von 1 läuft die Kühlung mit maximaler Kraft, bei 0 ist sie aus. 

### Ausgaben

Ergebnisgrößen des Modells sind:

- `ActiveLayerThermalLoad [W]`

Diese konstruktionsspezifischen Größen werden als vektorwertige Ergebnisgrößen bereitgestellt, mit Zugriff über die ID der Konstruktionsinstanz:
Z. B. ist `Model<IdealSurfaceHeatingCoolingModel_id>).ActiveLayerThermalLoad[id=3]` die Heizlast in Konstruktion #3.

[NOTE]
====
Die `ActiveLayerThermalLoad` ist positiv bei Beheizung der Fläche und negativ bei Kühlung. Die Wärme-/Kälteleistung ist eine absolute Größe (nicht flächenbezogen).
====



[[model_ideal_pipe_register]]
## Modell für idealisierte Rohrregister-Flächenheizungen

Das Modell beschreibt ein Rohrregister, welches zur Beheizung/Kühlung von Flächen verwendet werden kann. Dabei wird das Rohrnetzwerk im Gebäude nicht abgebildet, sondern eine Vorlauftemperatur als gegeben angenommen (daher _idealisiert_).
Das Rohrregistermodell ist auch deshalb _ideal_, weil es von stationären Bedingungen ausgeht, d.h. es wird von einem größtenteils konstant durchflossenem Rohr mit konstanten Rand- und Umgebungsbedingungen und konstanter Vorlauftemperatur ausgegangen. Entlang der Rohrschlange wird von konstanten Umgebungsbedingungen ausgegangen (es wird die Temperatur der aktiven Schicht verwendet). 

[NOTE]
====
Die Randbedingungen und Vorlauftemperatur können sich zwar während der Simulation ändern, jedoch sind die Gleichungen streng genommen nur für komplett stationäre Prozesse gültig.
====

.Definitionsblock für Rohrregister-Heizungen
====
[source,xml]
----
<IdealPipeRegisterModel id="701" displayName="Floor heating" modelType="Constant">
	<ThermostatZoneId>1</ThermostatZoneId>
	<ConstructionObjectList>Floor</ConstructionObjectList>
	<IBK:Parameter name="SupplyTemperature" unit="C">8</IBK:Parameter>
	<IBK:Parameter name="MaxMassFlux" unit="kg/s">0.2</IBK:Parameter>
	<IBK:Parameter name="PipeLength" unit="m">100</IBK:Parameter>
	<IBK:Parameter name="PipeInnerDiameter" unit="mm">25.6</IBK:Parameter>
	<IBK:Parameter name="UValuePipeWall" unit="W/mK">5</IBK:Parameter>
	<!-- The default value for number of pipes is 1, so this could be omitted. -->
	<IBK:IntPara name="NumberParallelPipes">1</IBK:IntPara>
	<!-- Fluid properties of water -->
	<HydraulicFluid displayName="Water">
		<IBK:Parameter name="Density" unit="kg/m3">998</IBK:Parameter>
		<IBK:Parameter name="HeatCapacity" unit="J/kgK">4180</IBK:Parameter>
		<IBK:Parameter name="Conductivity" unit="W/mK">0.6</IBK:Parameter>
		<LinearSplineParameter name="KinematicViscosity" interpolationMethod="linear">
			<X unit="C">0 90 </X>
			<Y unit="m2/s">1.307e-06 1.307e-06</Y>
		</LinearSplineParameter>
	</HydraulicFluid>
</IdealPipeRegisterModel>
----
====

Ein `IdealPipeRegisterModel` kann die Heiz- und Kühlleistung in mehreren Konstruktionen berechnen. Dafür identifiziert der Objektlisten-tag `ConstructionObjectList` die Konstruktion, welche durch das Modell beheizt werden. Jede beheizte Konstruktion darf nur von einem Modell angesprochen werden.

[IMPORTANT]
====
Die in der Objektliste referenzierten Konstruktionen müssen einen Konstruktionstyp haben, in dem eine aktive Schicht definiert ist (siehe <<construction_active_layer>>).
====

Die Heizleistung wird über die Anpassung des Massestroms in Abhängigkeit eines Thermostat-Kontrollsignals gesteuert. Die Zone, in der sich das Thermostat befindet, wird im Element `ThermostatZoneId` angegeben. 

Das `IdealPipeRegisterModel` unterstützt die folgenden XML-Attribute:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_

| `modelType` 
a| Definiert die Vorlauftemperatur

* `Constant` - Konstante Vorlauftemperatur
* `Scheduled` - Vorlauftemperatur ändert sich nach einem definierten Zeitplan.

| key | _erforderlich_
|====================

Wenn der Modelltyp `Scheduled` verwendet wird, sind folgende Zeitplanparameter erforderlich:

- `SupplyTemperatureSchedule [C]` 
- `MaxMassFluxSchedule [kg/s]`

Diese müssen für die Konstruktion definiert werden. Häufig ist es sinnvoll, die gleiche Objektliste für die Schedule-Definition wie auch für das `IdealPipeRegisterModel` zu verwenden.

Folgende Fließkommaparameter (siehe <<IBK_Parameter>> für eine Beschreibung des Elementtyps `IBK:Parameter`) sind anzugeben:

[options="header",cols="20%,^ 15%,35%,^ 20%,^ 10%",width="100%"]
|====================
|Name|Vorgabeeinheit|Beschreibung|Wertebereich |Verwendung
| `SupplyTemperature` | C | Vorlauftemperatur | {nbsp} >= -100.0 {nbsp} | _erforderlich nur für Modelltyp_ `Constant`
| `MaxMassFlux` | kg/s | Maximaler Massestrom durch das _gesamte_ Rohrregister | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich nur für Modelltyp_ `Constant`
| `PipeLength` | m | Länge eines Rohrs im Rohrregister | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `PipeInnerDiameter` | m | Innendurchmesser des Rohrs | {nbsp}>={nbsp}0.0{nbsp} | _erforderlich_ 
| `UValuePipeWall` | W/mK | Längenbezogener äquivalenter U-Wert der Rohrwand | {nbsp}>{nbsp}0.0{nbsp}  | _erforderlich_ 
|====================

Der Parameter `NumberParallelPipes` gibt an, wie viele Rohre parallel in der Konstruktion durchströmt werden. Der insgesamt durchströmte Querschnitt ergibt somit aus dem Querschnitt eines Rohres mal Anzahl parallel durchströmter Rohre.

Diese Angabe hat Einfluss auf die Berechnung der Strömungsgeschwindigkeit, da der Massenstrom durch das Rohrregister gleichmäßig auf alle parallelen Stränge aufgeteilt wird. Dies hat auch Auswirkung auf den Begrenzungsparameter `MaxMassFlux`. Ist dieser bspw. auf 0,1 kg/s eingestellt, und es sind zwei parallele Rohrregister verbaut (`NumberParallelPipes=2`), so wird jedes der parallel verlegten Rohre mit max. 0,05 kg/s durchströmt.


[TIP]
====
Wenn man eine einzelne Rohrschlange in einer Konstruktion modelliert, dann gibt man die Länge der Rohrschlange und als `NumberParallelPipes` 1 an. Verlegt man mehrere Rohrschlangen, bzw. hat parallele Rohre, dann gibt man als Rohrlänge jeweils die Länge eines einzelnen Rohres an und die Anzahl der Rohrschlangen/parallel verlegten Rohre.
====


### Heiz- und Kühlleistung

Das Regelsignal `HeatingControlValue` wird als Wert zwischen 0..1 intepretiert. Werte außerhalb dieser Grenzen werden abgeschnitten. Bei 1 wird der maximale Massestrom für Heizung auf den Wert `MaxMassFlow` gesetzt. Bei 0 ist die Heizung aus (Massestrom = 0). Dazwischen wird linear interpoliert.

Die Kühlung ist genauso definiert. Bei einem Kontrollwert von 1 läuft die Kühlung mit maximaler Kraft, bei 0 ist sie aus.

[IMPORTANT]
====
Grundsätzlich kann ein Rohrregister nur Wärme abgeben, wenn die Vorlauftemperatur höher aus die Schichttemperatur ist. Daher wird auch bei einer Heizanforderung durch das Thermostat der Massestrom auf 0 gesetzt, wenn die Vorlauftemperatur zu klein wird.

Dadurch ist es auch niemals möglich, dass sowohl Heizung als auch Kühlung berechnet wird. Also selbst wenn das Thermostat sowohl Heiz- als auch Kühlanforderung gibt, kann es immer nur entweder Heizung oder Kühlung geben, je nach Vorlauf- und Schichttemperatur.
==== 


### Ausgaben

Ergebnisgrößen des Modells sind:

- `MassFlux [kg/s]`
- `ActiveLayerThermalLoad [W]`

Diese konstruktionsspezifischen Größen werden als vektorwertige Ergebnisgrößen bereitgestellt, mit Zugriff über die ID der Konstruktionsinstanz:
Z. B. ist `Model<IdealSurfaceHeatingCoolingModel_id>).ActiveLayerThermalLoad[id=3]` die Heizlast in Konstruktion #3.

[NOTE]
====
Die `ActiveLayerThermalLoad` ist positiv bei Beheizung der Fläche und negativ bei Kühlung. Die Wärme-/Kälteleistung ist eine absolute Größe (nicht flächenbezogen).
====



[[model_heat_load_summation]]
## Modell für die Summation von Heiz- und Kühlleistungen

Das Modell summiert die Heizleistungen der ausgewählten Objekte und liefert die Gesamtwärmeleistung (Heizung/Kühlung).

.Definitionsblock für ein Summationsmodell
====
[source,xml]
----
<HeatLoadSummationModel id="801" displayName="Floor heating loads">
	<ObjectList>Floors</ObjectList>
</HeatLoadSummationModel>
----
====

Das `HeatLoadSummationModel` muss mit den folgenden XML-Attributen definiert werden:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_
| `useZoneCoolingLoad` | für die SUmmation idealer Zonenlasten, 'true' für Kühllasten, 'false' für Heizlasten (default) = 'false'  | string | _optional_
|====================

Ein `HeatLoadSummationModel` summiert die idealen Heiz- oder Kühllasten mehrerer Räume, die Wärmelasten in Konstruktionen oder in hydraulische Netzwerke. Nur
einer der Typen `Zone`, `ConstuctionInstance`, `Networkelement` ist dabei im Modell erlaubt. Dafür identifiziert der Objektlisten-tag `ObjectList` den Objekttyp und die 
Auswahl von Räumen/Konstruktionen/Netzwerkelementen, deren Heizlast erfasst und summiert werden soll. Im Fall der idealen Raumbeheizung oder Raumkühlung
ist durch die Option `useZoneCoolingLoad` die passende Lastart (Heizung oder Kühlung) auszuwählen.

[NOTE]
====
Falls in der Objektliste referenzierte Konstruktionen keine aktive Schicht definiert haben (siehe <<construction_active_layer>>), so werden diese einfach ignoriert.
====

### Ausgaben

Das Modell liefert die Summe der thermischen Lasten in der Ergebnisgröße `TotalThermalLoad`.

[NOTE]
====
Die `TotalThermalLoad` ist positiv bei Beheizung von Räumen, Flächen und negativ bei Kühlung. Innerhalb von Netzwerken entspricht eine positive Last der Wärmeaufnahme des Fluides und negativ der
Wärmeabgabe im Fluid. Imstationären Fall entspricht die `TotalThermalLoad` in allen aktiv geheizten Netzwerkelementen also exakt der `TotalThermalLoad` in die geheizten Konstruktionen.
====



[[model_network_interface_adapter]]
## Schnittstellen-Modell für die Anbindung externer Anlagennetze 

Diese Modell ist für alleinstehende Simulationen unwichtig und wird primär für die Co-Simulation mittels FMI gebraucht. Es bildet den Wärmeentzug des Gebäudes auf ein strömendes Medium ab, bspw. ein Versorgungsnetzwerk. Das Medium strömt mit gegebener Vorlauftemperatur und Massenstrom ins Gebäude und das `NetworkInterfaceAdapterModel` berechnet die resultierende Rücklauftemperatur.

Vorlauftemperatur und Massenstrom werden als Zeitpläne benötigt:

- `SupplyTemperatureSchedule [C]`
- `MassFluxSchedule [kg/s]`

Bei Verwendung der FMI-Kopplung sind diese Größen durch FMI-Input-Variablen zu überschreiben.

.Definitionsblock für ein solches Schnittstellenmodell
====
[source,xml]
----
<NetworkInterfaceAdapterModel id="802" summationModelId="801">
	<IBK:Parameter name="FluidHeatCapacity" unit="J/kgK">4180</IBK:Parameter>
</NetworkInterfaceAdapterModel>
----
====

Das `NetworkInterfaceAdapterModel` muss mit den folgenden XML-Attributen definiert werden:

.Attribute
[.indent-me]
[options="header",cols="20%,60%,^ 10%,^ 10%",width="100%"]
|====================
| Attribut | Beschreibung | Format | Verwendung 
| `id` | Kennung des Modells | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
| `displayName` | Anzeigename/Beschreibung | string | _optional_
| `summationModelId` | ID des Summationsmodells, welches die Heiz-/Kühlleistung im Gebäude berechnet | {nbsp}>{nbsp}0{nbsp} | _erforderlich_
|====================

Für die Berechnung ist die spezifische Wärmekapazität des strömenden Mediums notwendig, angegeben im IBK-Parameterelement `FluidHeatCapacity`. 

### Ausgaben

Das Modell hat eine einzige Ergebnisgröße:

- `ReturnTemperature [C]`

[CAUTION]
====
Der Wärmeentzug aus dem Versorgungsstrang erfolgt unabhängig eventueller physikalischer Grenzen. In der Realität die Rücklauftemperatur niemals unterhalb der Raum-/Konstruktionstemperatur sinken.  Bei Einsatz dieses Modells ist zwar die Energiebilanz stets erfüllt, aber die Rücklauftemperatur kann sehr niedrig werden. Entsprechend sollten nachfolgende Modelle diese Temperatur nur für Regelungen als Sensorgröße behandeln und ggfs. auf sinnvolle Wertebereiche begrenzen.
====
